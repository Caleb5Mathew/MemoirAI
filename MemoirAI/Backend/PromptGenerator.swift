////  PromptGenerator.swift//  MemoirAI////  Created by user941803 on 5/9/25.//  Updated to handle dual output (image prompt + page text)//  with robust delimiter-based parsing.//import Foundation// Define the structure to hold both image prompt and page text.// This struct should ideally be moved to a shared Models.swift file.struct StoryPageContent: Identifiable {    let id = UUID()    let imagePromptText: String // For DALL-E    let pageDisplayText: String   // Text to show on the page}// Assuming ArtStyle enum is globally accessible.// enum ArtStyle: String, CaseIterable, Identifiable { ... }// Assuming PromptTemplates.swift with its static functions is accessible.// enum PromptTemplates { ... }actor PromptGenerator {    private let apiKey: String    private let session: URLSession    // Define delimiters for parsing    private let imagePromptStartTag = "IMAGE_PROMPT_START"    private let imagePromptEndTag = "IMAGE_PROMPT_END"    private let pageTextStartTag = "PAGE_TEXT_START"    private let pageTextEndTag = "PAGE_TEXT_END"    private let sceneDividerTag = "---SCENE_DIVIDER---"    init(session: URLSession = .shared) {        guard let key = Bundle.main                .object(forInfoDictionaryKey: "OPENAI_API_KEY") as? String,              !key.isEmpty else {            fatalError("ðŸ”‘ Missing OPENAI_API_KEY in Info.plist")        }        print("[PromptGenerator] Loaded key prefix: \(key.prefix(5))â€¦")        self.apiKey = key        self.session = session    }    /// Generate up to `pageCount` items, each containing an image prompt and page text, tailored by art style.    func generatePrompts(        from transcript: String,        pageCount n: Int,        chosenArtStyle: ArtStyle,        customArtStyleDetails: String?    ) async throws -> [StoryPageContent] {        print("[PromptGenerator DEBUG] generatePrompts called.")        print("[PromptGenerator DEBUG]   Parameters: transcript length: \(transcript.count), pageCount (n): \(n), artStyle: \(chosenArtStyle.rawValue), customDetails: \(customArtStyleDetails ?? "nil")")        guard !apiKey.isEmpty else {            print("[PromptGenerator ERROR] API Key is missing. Cannot make request to Chat Completions API.")            throw URLError(.userAuthenticationRequired)        }        let systemMessageContent = PromptTemplates.systemPrompt(for: chosenArtStyle, customArtStyleDetails: customArtStyleDetails)        let userMessageContent = PromptTemplates.userMessage(transcript: transcript, pageCount: n)        // Log prefixes of messages for brevity in most cases        print("[PromptGenerator DEBUG] System Message (length: \(systemMessageContent.count)): \"\(systemMessageContent.prefix(300))...\"")        print("[PromptGenerator DEBUG] User Message (length: \(userMessageContent.count)): \"\(userMessageContent.prefix(200))...\"")        let payload: [String: Any] = [            "model": "gpt-4o", // Ensure this is the desired, accessible model            "messages": [                ["role": "system", "content": systemMessageContent],                ["role": "user",   "content": userMessageContent]            ]        ]                // For very detailed debugging of the payload, uncomment the next line.        // print("[PromptGenerator DEBUG] Full Request Payload:\n\(payload)")        guard let url = URL(string: "https://api.openai.com/v1/chat/completions") else {            print("[PromptGenerator ERROR] Invalid URL string for Chat Completions API.")            throw URLError(.badURL)        }        // ... (rest of the network request setup is the same) ...        var req = URLRequest(url: url)        req.httpMethod = "POST"        req.addValue("Bearer \(apiKey)", forHTTPHeaderField: "Authorization")        req.addValue("application/json", forHTTPHeaderField: "Content-Type")        do {            req.httpBody = try JSONSerialization.data(withJSONObject: payload)        } catch {            print("[PromptGenerator ERROR] Failed to serialize JSON payload: \(error.localizedDescription)")            throw error        }        print("[PromptGenerator DEBUG] Sending request to OpenAI Chat Completions API...")        let data: Data        let response: URLResponse        do {            (data, response) = try await session.data(for: req)            print("[PromptGenerator DEBUG] Received response from API.")        } catch {            print("[PromptGenerator ERROR] Network request to Chat Completions API failed: \(error.localizedDescription)")            if let urlError = error as? URLError {                print("[PromptGenerator ERROR] URLError details: Code \(urlError.code), UserInfo \(urlError.userInfo)")            }            throw error        }        guard let httpResponse = response as? HTTPURLResponse else {            print("[PromptGenerator ERROR] Response is not an HTTPURLResponse.")            throw URLError(.cannotParseResponse)        }        print("[PromptGenerator DEBUG] HTTP Status Code: \(httpResponse.statusCode)")        let responseBodyString = String(data: data, encoding: .utf8) ?? "Could not decode response body as UTF-8 string."        if !(200...299).contains(httpResponse.statusCode) {            print("[PromptGenerator ERROR] API returned non-2xx status code: \(httpResponse.statusCode).")            print("[PromptGenerator ERROR] Response Body:\n\(responseBodyString)")            throw URLError(.badServerResponse, userInfo: ["statusCode": httpResponse.statusCode, "responseBody": responseBodyString])        }                print("[PromptGenerator DEBUG] Raw response data (length: \(data.count)):\n\(responseBodyString)")        struct ChatChoice: Codable {            struct Message: Codable { let content: String? }            let message: Message            let finish_reason: String?        }        struct ChatResponse: Codable {            let choices: [ChatChoice]            let usage: Usage?            struct Usage: Codable {                let prompt_tokens: Int; let completion_tokens: Int; let total_tokens: Int            }        }                let decodedResponse: ChatResponse        do {            decodedResponse = try JSONDecoder().decode(ChatResponse.self, from: data)            print("[PromptGenerator DEBUG] Successfully decoded JSON response.")            if let usage = decodedResponse.usage {                print("[PromptGenerator DEBUG] Token Usage: Prompt=\(usage.prompt_tokens), Completion=\(usage.completion_tokens), Total=\(usage.total_tokens)")            }        } catch {            print("[PromptGenerator ERROR] Failed to decode JSON response: \(error.localizedDescription)")            print("[PromptGenerator ERROR]   Attempted to decode data:\n\(responseBodyString)")            throw error        }        guard let firstChoice = decodedResponse.choices.first else {            print("[PromptGenerator WARNING] No choices found in Chat API response. Raw response:\n\(responseBodyString)")            return []        }                if let finishReason = firstChoice.finish_reason, finishReason != "stop" && finishReason != "length" {            print("[PromptGenerator WARNING] Finish reason was '\(finishReason)' not 'stop'. Content might be incomplete or truncated.")        }        let rawContent = firstChoice.message.content ?? ""        print("[PromptGenerator DEBUG] Raw content from first choice (length: \(rawContent.count)):\n'\(rawContent)'")        // Handle AI indicating inability to generate        if rawContent.contains("I am unable to generate storybook content from the provided transcript with the current settings.") {            print("[PromptGenerator INFO] AI indicated it cannot generate content from the transcript. Returning empty array.")            return []        }        if rawContent.isEmpty {            print("[PromptGenerator WARNING] Raw content from API is empty. Returning empty array.")            return []        }                // --- NEW DELIMITER-BASED PARSING LOGIC ---        var generatedStoryContents: [StoryPageContent] = []                // Split the entire AI response by the scene divider.        // The AI is instructed to omit the divider after the LAST scene.        let sceneDataBlocks = rawContent.components(separatedBy: sceneDividerTag)                print("[PromptGenerator DEBUG] Split rawContent into \(sceneDataBlocks.count) blocks using scene divider '\(sceneDividerTag)'.")        for (index, block) in sceneDataBlocks.enumerated() {            let trimmedBlock = block.trimmingCharacters(in: .whitespacesAndNewlines)            if trimmedBlock.isEmpty {                print("[PromptGenerator DEBUG] Block \(index + 1) is empty after trimming. Skipping.")                continue            }            print("[PromptGenerator DEBUG] Processing scene block \(index + 1):\n'\(trimmedBlock)'")            guard let imgPromptStartRange = trimmedBlock.range(of: imagePromptStartTag),                  let imgPromptEndRange = trimmedBlock.range(of: imagePromptEndTag, range: imgPromptStartRange.upperBound..<trimmedBlock.endIndex) else {                print("[PromptGenerator WARNING] Could not find image prompt start/end tags in block \(index + 1). Content: '\(trimmedBlock.prefix(100))...'")                continue // Skip this block if tags are missing            }                        let imagePromptText = String(trimmedBlock[imgPromptStartRange.upperBound..<imgPromptEndRange.lowerBound])                .trimmingCharacters(in: .whitespacesAndNewlines)            guard let pageTextStartRange = trimmedBlock.range(of: pageTextStartTag, range: imgPromptEndRange.upperBound..<trimmedBlock.endIndex),                  let pageTextEndRange = trimmedBlock.range(of: pageTextEndTag, range: pageTextStartRange.upperBound..<trimmedBlock.endIndex) else {                print("[PromptGenerator WARNING] Could not find page text start/end tags in block \(index + 1) after image prompt. Content: '\(trimmedBlock.prefix(100))...'")                // Create content even if page text is missing, but log it.                if !imagePromptText.isEmpty {                    generatedStoryContents.append(StoryPageContent(imagePromptText: imagePromptText, pageDisplayText: ""))                    print("[PromptGenerator DEBUG]   Created StoryPageContent with IMAGE_PROMPT_TEXT only for block \(index + 1): \"\(imagePromptText.prefix(100))...\"")                }                continue            }                        let pageDisplayText = String(trimmedBlock[pageTextStartRange.upperBound..<pageTextEndRange.lowerBound])                .trimmingCharacters(in: .whitespacesAndNewlines)            if imagePromptText.isEmpty && pageDisplayText.isEmpty {                print("[PromptGenerator WARNING] Both image prompt and page text are empty for block \(index + 1). Skipping.")                continue            }                        // Regex to remove any accidental leading numbering (e.g., "1. ") from the content itself.            let finalImagePromptText = imagePromptText.replacingOccurrences(of: #"^\s*\d+\.\s*"#, with: "", options: .regularExpression)            let finalPageDisplayText = pageDisplayText.replacingOccurrences(of: #"^\s*\d+\.\s*"#, with: "", options: .regularExpression)            print("[PromptGenerator DEBUG]   Extracted Image Prompt Text: \"\(finalImagePromptText.prefix(100))...\"")            print("[PromptGenerator DEBUG]   Extracted Page Display Text: \"\(finalPageDisplayText.prefix(100))...\"")                        let storyElement = StoryPageContent(imagePromptText: finalImagePromptText, pageDisplayText: finalPageDisplayText)            generatedStoryContents.append(storyElement)            print("[PromptGenerator DEBUG]     Created StoryPageContent (ID: \(storyElement.id))")        }        // --- END OF NEW DELIMITER-BASED PARSING LOGIC ---                print("[PromptGenerator DEBUG] Finished processing. Generated \(generatedStoryContents.count) StoryPageContent items.")                if generatedStoryContents.count > n {            print("[PromptGenerator WARNING] AI generated \(generatedStoryContents.count) items, but only \(n) were requested. Truncating to \(n) items.")            generatedStoryContents = Array(generatedStoryContents.prefix(n))        } else if generatedStoryContents.count < n &&                  !rawContent.lowercased().contains("fewer than n truly pivotal moments") &&                  !rawContent.lowercased().contains("unable to generate storybook content from the provided transcript with the current settings") {            print("[PromptGenerator WARNING] Requested \(n) items but AI generated only \(generatedStoryContents.count). This might be due to transcript length or AI interpretation. The system prompt allows for fewer than N if not enough pivotal moments are found.")        }                return generatedStoryContents    }}extension PromptGenerator {  /// Keep your old call-site happy â€“ just forward to the zero-arg init  convenience init(apiKey: String, session: URLSession = .shared) {    self.init(session: session)  }}