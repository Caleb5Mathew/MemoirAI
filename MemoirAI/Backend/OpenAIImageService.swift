////  OpenAIImageService.swift//  MemoirAI////  Created by user941803 on 5/9/25.//import Foundationimport UIKit// For a more structured logging approach in a production app, consider using OSLog.// import os.log // Uncomment if you want to use OSLog/// Wraps OpenAI’s Images API (/v1/images/generations) to turn text prompts/// into UIImages. (Future: support image-guided variations.)actor OpenAIImageService {    // private static let logger = Logger(subsystem: Bundle.main.bundleIdentifier!, category: "OpenAIImageService") // Example for OSLog    /// Shared singleton for easy injection    static let shared = OpenAIImageService()    private let apiKey: String    private let session: URLSession    /// Initialize with your API key from Info.plist    init(        apiKey: String = Bundle.main            .object(forInfoDictionaryKey: "OPENAI_API_KEY") as? String ?? "",        session: URLSession = .shared    ) {        print("[OpenAIImageService DEBUG] Initializing OpenAIImageService...")        if apiKey.isEmpty {            print("[OpenAIImageService WARNING] API Key is EMPTY. Please ensure 'OPENAI_API_KEY' is set in Info.plist.")        } else {            // Avoid logging the full key in production logs if possible, but for debugging it's shown here.            // Consider logging only a portion like the first few characters in a real app if needed.            print("[OpenAIImageService DEBUG] API Key loaded: \(apiKey.count > 5 ? apiKey.prefix(5) + "..." : apiKey)")        }        self.apiKey = apiKey        self.session = session        print("[OpenAIImageService DEBUG] OpenAIImageService initialized. Session: \(session)")    }    /// Generate `n` images of given `size` from a text `prompt`.    /// - Parameters:    ///   - prompt: The text prompt describing the scene.    ///   - n: Number of images to generate (1–10).    ///   - size: Resolution string, e.g. "1024x1024" or "512x512".    /// - Returns: An array of UIImages.    func generateImages(        prompt: String,        n: Int = 1,        size: String = "1024x1024"    ) async throws -> [UIImage] {        print("[OpenAIImageService DEBUG] generateImages(prompt:\"\(prompt)\", n:\(n), size:\(size)) called.")        guard !apiKey.isEmpty else {            print("[OpenAIImageService ERROR] API Key is missing. Cannot make request.")            throw URLError(.userAuthenticationRequired) // Or a custom error        }        // Build request        let urlString = "https://api.openai.com/v1/images/generations"        guard let url = URL(string: urlString) else {            print("[OpenAIImageService ERROR] Invalid URL string: \(urlString)")            throw URLError(.badURL)        }        print("[OpenAIImageService DEBUG] Request URL: \(url.absoluteString)")        var req = URLRequest(url: url)        req.httpMethod = "POST"        req.addValue("Bearer \(apiKey)", forHTTPHeaderField: "Authorization")        req.addValue("application/json", forHTTPHeaderField: "Content-Type")        print("[OpenAIImageService DEBUG] Request headers set. Authorization: Bearer \(apiKey.prefix(5))..., Content-Type: application/json")        // JSON body        let body: [String: Any] = [            "model": "dall-e-3", // Assuming dall-e-3, update if "gpt-image-1" is a specific internal model name. Common models are dall-e-2 or dall-e-3.            "prompt": prompt,            "n": n,            "size": size,            "response_format": "url" // Explicitly requesting URL, b64_json is another option        ]        print("[OpenAIImageService DEBUG] Request body: \(body)")        do {            req.httpBody = try JSONSerialization.data(withJSONObject: body)            print("[OpenAIImageService DEBUG] HTTP body serialized successfully. Size: \(req.httpBody?.count ?? 0) bytes.")        } catch {            print("[OpenAIImageService ERROR] Failed to serialize JSON body: \(error.localizedDescription)")            throw error        }        // Send        print("[OpenAIImageService DEBUG] Sending request to OpenAI API...")        let data: Data        let resp: URLResponse        do {            (data, resp) = try await session.data(for: req)            print("[OpenAIImageService DEBUG] Received response from API.")        } catch {            print("[OpenAIImageService ERROR] Network request failed: \(error.localizedDescription)")            throw error        }                guard let http = resp as? HTTPURLResponse else {            print("[OpenAIImageService ERROR] Response is not an HTTPURLResponse.")            throw URLError(.cannotParseResponse)        }        print("[OpenAIImageService DEBUG] HTTP Status Code: \(http.statusCode)")        if !(200...299).contains(http.statusCode) {            let responseBodyString = String(data: data, encoding: .utf8) ?? "Could not decode error response body."            print("[OpenAIImageService ERROR] API returned non-2xx status code: \(http.statusCode). Response Body: \(responseBodyString)")            // Consider decoding OpenAI specific error structure here if available            throw URLError(.badServerResponse, userInfo: ["statusCode": http.statusCode, "responseBody": responseBodyString])        }        print("[OpenAIImageService DEBUG] Response data received. Size: \(data.count) bytes.")        if let responseString = String(data: data, encoding: .utf8) {             print("[OpenAIImageService DEBUG] Raw response JSON string: \(responseString)")        }        // Decode URLs        struct Response: Codable {            struct Entry: Codable { let url: String? } // URL might be optional or b64_json            let data: [Entry]            // Add other fields like 'created' if needed for debugging        }                let decoded: Response        do {            decoded = try JSONDecoder().decode(Response.self, from: data)            print("[OpenAIImageService DEBUG] Successfully decoded JSON response.")            print("[OpenAIImageService DEBUG] Decoded response contains \(decoded.data.count) data entries.")        } catch {            print("[OpenAIImageService ERROR] Failed to decode JSON response: \(error.localizedDescription). Data received: \(String(data: data, encoding: .utf8) ?? "Non-UTF8 data")")            throw error        }        let urls = decoded.data.compactMap { entry -> URL? in            guard let urlString = entry.url else {                print("[OpenAIImageService WARNING] Found entry with nil URL in response.")                return nil            }            print("[OpenAIImageService DEBUG] Image URL from response: \(urlString)")            return URL(string: urlString)        }        print("[OpenAIImageService DEBUG] Extracted \(urls.count) valid image URLs from response.")        // Download images        var images: [UIImage] = []        print("[OpenAIImageService DEBUG] Starting to download \(urls.count) images...")        for (index, imageURL) in urls.enumerated() {            print("[OpenAIImageService DEBUG] Downloading image \(index + 1) of \(urls.count) from URL: \(imageURL.absoluteString)")            do {                let (imgData, imgResp) = try await session.data(from: imageURL)                guard let httpImg = imgResp as? HTTPURLResponse, httpImg.statusCode == 200 else {                    print("[OpenAIImageService WARNING] Failed to download image from \(imageURL). Status: \((imgResp as? HTTPURLResponse)?.statusCode ?? -1). Skipping this image.")                    continue                }                print("[OpenAIImageService DEBUG] Image data downloaded successfully for URL: \(imageURL.absoluteString). Size: \(imgData.count) bytes.")                if let ui = UIImage(data: imgData) {                    images.append(ui)                    print("[OpenAIImageService DEBUG] Successfully created UIImage from data for URL: \(imageURL.absoluteString). Image size: \(ui.size)")                } else {                    print("[OpenAIImageService WARNING] Failed to create UIImage from downloaded data for URL: \(imageURL.absoluteString). Data might be corrupt or not an image.")                }            } catch {                print("[OpenAIImageService WARNING] Error downloading image data from \(imageURL): \(error.localizedDescription). Skipping this image.")                continue            }        }        print("[OpenAIImageService DEBUG] Finished downloading images. Total images created: \(images.count) out of \(urls.count) URLs.")                if images.isEmpty && !decoded.data.isEmpty {             print("[OpenAIImageService WARNING] No images were successfully downloaded despite receiving \(decoded.data.count) URLs/entries from API.")        }        return images    }    /// Generate images for an array of prompts in one go.    /// - Parameters:    ///   - prompts: Array of ImagePrompt (text).    ///   - n: Number of images per prompt (defaults to 1).    ///   - size: Resolution string, e.g. "1024x1024".    /// - Returns: Flattened array of UIImages (in order of prompts).    func generateImages(        from prompts: [ImagePrompt],        n: Int = 1,        size: String = "1024x1024"    ) async throws -> [UIImage] {        print("[OpenAIImageService DEBUG] generateImages(from prompts: \(prompts.count) items, n: \(n), size: \(size)) called.")        var allImages: [UIImage] = []        for (index, prompt) in prompts.enumerated() {            print("[OpenAIImageService DEBUG] Processing prompt #\(index + 1) of \(prompts.count): \"\(prompt.text)\" (ID: \(prompt.id))")            do {                let imgs = try await generateImages(prompt: prompt.text, n: n, size: size)                print("[OpenAIImageService DEBUG] Received \(imgs.count) images for prompt #\(index + 1).")                allImages.append(contentsOf: imgs)            } catch {                print("[OpenAIImageService ERROR] Failed to generate images for prompt #\(index + 1) (\"\(prompt.text)\"): \(error.localizedDescription). This prompt will be skipped.")                // Optionally rethrow, or collect errors. Current behavior: skips failing prompts.                // throw error // Uncomment to make the whole batch fail if one prompt fails            }        }        print("[OpenAIImageService DEBUG] Finished processing all prompts. Total images generated: \(allImages.count).")        return allImages    }    /// Stub for future “text+photo” enrichment or variation support.    /// Right now, just returns the original prompt.    func enrichPrompt(_ prompt: String, with photos: [UIImage]) async throws -> String {        print("[OpenAIImageService DEBUG] enrichPrompt(\"\(prompt)\", with photos: \(photos.count)) called.")        // When implemented, add detailed logging for the actual enrichment process.        print("[OpenAIImageService DEBUG] enrichPrompt is currently a STUB. Returning original prompt.")        return prompt    }}