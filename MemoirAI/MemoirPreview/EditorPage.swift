import Foundationimport SwiftUIimport CoreDataimport UIKit@MainActorclass EditorPage: ObservableObject, Identifiable {    let id = UUID()    // Editable properties    @Published var title: String?    @Published var bodyText: String    @Published var photoData: Data?    let isCover: Bool    // Non-editable helpers    private let memory: MemoryEntry?    private let context: NSManagedObjectContext    init(title: String?, body: String, photo: Data?, memory: MemoryEntry?, context: NSManagedObjectContext, isCover: Bool = false) {        self.title = title        self.bodyText = body        self.photoData = photo        self.memory = memory        self.context = context        self.isCover = isCover    }    var photoUIImage: UIImage? { photoData.flatMap { UIImage(data: $0) } }    var qrUIImage: UIImage? {        guard let id = memory?.id else { return nil }        return UIImage.qrCode(from: "memoirai://memory/\(id.uuidString)", size: 120)    }    static func pages(from memories: [MemoryEntry], context: NSManagedObjectContext) -> [EditorPage] {        // Enhanced page size for realistic book proportions        let pageSize = CGSize(width: 300, height: 400) // Better book proportions        let textAreaSize = CGSize(            width: pageSize.width - 72, // Account for inner + outer margins            height: pageSize.height - 104 // Account for head + foot margins        )        let font = UIFont(name: "Georgia", size: 11) ?? UIFont.systemFont(ofSize: 11, weight: .regular)        var allPages = [EditorPage]()        for mem in memories {            let text = mem.text ?? ""            let paginatedText = paginate(text: text, for: textAreaSize, with: font)            // Grab first photo (if any) tied to this memory via CoreData relationship            let photoData = (mem.photos as? Set<Photo>)?.first?.data            if paginatedText.isEmpty {                // Empty memory â€“ create a single (blank) page                let page = EditorPage(                    title: mem.prompt ?? "Untitled",                    body: "",                    photo: photoData,                    memory: mem,                    context: context                )                allPages.append(page)            } else {                // Create pages for this memory with better text distribution                for (index, pageText) in paginatedText.enumerated() {                    let page = EditorPage(                        title: index == 0 ? (mem.prompt ?? "Untitled") : nil, // Title only on first page                        body: pageText,                        photo: index == 0 ? photoData : nil,              // Photo only on first page                        memory: mem,                        context: context                    )                    allPages.append(page)                }            }        }        return allPages    }    private static func paginate(text: String, for size: CGSize, with font: UIFont) -> [String] {        guard !text.isEmpty else { return [] }                let paragraphs = text.components(separatedBy: .newlines)        var pages: [String] = []        var currentPage = ""                // Account for different content on first page vs continuation pages        var isFirstPage = true        let firstPageHeight = size.height * 0.75 // Reserve space for title and potential photo        let regularPageHeight = size.height * 0.90 // More space for continuation pages                for paragraph in paragraphs {            guard !paragraph.trimmingCharacters(in: .whitespaces).isEmpty else { continue }                        let paragraphWithBreak = paragraph + "\n\n"            let testText = currentPage + paragraphWithBreak                        let currentPageHeight = isFirstPage ? firstPageHeight : regularPageHeight            let measuredHeight = textHeight(for: testText, font: font, width: size.width)                        if measuredHeight <= currentPageHeight {                // Fits on current page                currentPage += paragraphWithBreak            } else {                // Doesn't fit - start new page                if !currentPage.isEmpty {                    pages.append(currentPage.trimmingCharacters(in: .whitespacesAndNewlines))                    currentPage = ""                    isFirstPage = false                }                                // Check if this paragraph needs to be split further                if textHeight(for: paragraphWithBreak, font: font, width: size.width) > regularPageHeight {                    // Split paragraph by sentences for better flow                    let sentences = splitIntoSentences(paragraph)                    var currentSentence = ""                                        for sentence in sentences {                        let testSentence = currentSentence + sentence + " "                                                if textHeight(for: testSentence, font: font, width: size.width) <= regularPageHeight {                            currentSentence = testSentence                        } else {                            if !currentSentence.isEmpty {                                pages.append(currentSentence.trimmingCharacters(in: .whitespacesAndNewlines))                                currentSentence = sentence + " "                            } else {                                // Even single sentence is too long - just add it                                pages.append(sentence.trimmingCharacters(in: .whitespacesAndNewlines))                            }                        }                    }                                        if !currentSentence.isEmpty {                        currentPage = currentSentence + "\n\n"                    }                } else {                    currentPage = paragraphWithBreak                }            }        }                // Add final page        if !currentPage.isEmpty {            pages.append(currentPage.trimmingCharacters(in: .whitespacesAndNewlines))        }                return pages    }        private static func textHeight(for text: String, font: UIFont, width: CGFloat) -> CGFloat {        let attributes = [NSAttributedString.Key.font: font]        let size = CGSize(width: width, height: .greatestFiniteMagnitude)        let rect = text.boundingRect(with: size, options: [.usesLineFragmentOrigin, .usesFontLeading], attributes: attributes, context: nil)        return rect.height    }    // Helper to split text into sentences more intelligently    private static func splitIntoSentences(_ text: String) -> [String] {        let sentences = text.components(separatedBy: CharacterSet(charactersIn: ".!?"))        return sentences.compactMap { sentence in            let trimmed = sentence.trimmingCharacters(in: .whitespacesAndNewlines)            return trimmed.isEmpty ? nil : trimmed        }    }    func persistChanges() {        guard let mem = memory else { return }        mem.prompt = title        mem.text   = bodyText        if let data = photoData {            // Update or create a Photo entity            let existing = (mem.photos as? Set<Photo>)?.first            if let p = existing {                p.data = data            } else {                let newPhoto = Photo(context: context)                newPhoto.id = UUID()                newPhoto.data = data                newPhoto.memoryEntry = mem            }        }        do { try context.save() } catch {            print("EditorPage save error", error.localizedDescription)        }    }} 