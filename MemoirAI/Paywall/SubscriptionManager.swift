import Foundationimport RevenueCatimport SwiftUI// (Make sure Purchases and other RevenueCat imports are available)/// Subscription tiers with their monthly page allowancesenum Tier: String, CaseIterable {    case basic   = "com.Buildr.MemoirAI.Monthly"    case premium = "com.Buildr.MemoirAI.PremiumMonthly" // Ensure this ID matches your Premium product    case pro     = "com.Buildr.MemoirAI.ProMonthly"     // Ensure this ID matches your Pro product    var allowance: Int { // Pages per month        switch self {        case .basic:   return 100        case .premium: return 300 // As per your new request        case .pro:     return 200 // As per your new request        }    }    var displayName: String {        switch self {        case .basic: return "Basic"        case .premium: return "Premium"        case .pro: return "Pro"        }    }}@MainActorfinal class RCSubscriptionManager: NSObject, ObservableObject {    static let shared = RCSubscriptionManager()    @Published var offerings: Offerings?    @Published var activeTier: Tier?    @Published var remainingAllowance: Int = 0 // This will now be remaining pages    private let allowanceKeyPrefix = "memoirai_page_allowance_" // Changed for clarity    private let lastResetPrefix    = "memoirai_page_lastReset_" // Changed for clarity    private override init() {        super.init()        Purchases.shared.delegate = self        Task {            await loadOfferings()            await refreshCustomerInfo()        }    }    func loadOfferings() async {        do {            offerings = try await Purchases.shared.offerings()            print("RCManager: Offerings loaded successfully.")        } catch {            print("❌ RCManager: Offerings error: \(error)")            offerings = nil // Ensure offerings are nil on error        }    }    func refreshCustomerInfo() async {        do {            let info = try await Purchases.shared.customerInfo()            print("RCManager: CustomerInfo refreshed. Entitlements: \(info.entitlements.active.keys)")            evaluateEntitlements(from: info)        } catch {            print("❌ RCManager: CustomerInfo error: \(error)")            // When there's an error fetching customer info, it's safer to assume no active tier            // unless you have a more sophisticated offline handling strategy.            activeTier = nil            remainingAllowance = 0        }    }    private func evaluateEntitlements(from info: CustomerInfo) {        var determinedTier: Tier? = nil        // Iterate through all known tiers and check if their corresponding entitlement is active.        // This makes it more robust if product IDs in entitlements match tier rawValues.        // Prioritize higher tiers if multiple somehow become active (though typically not the case with standard setup).        if info.entitlements.active.values.contains(where: { $0.productIdentifier == Tier.pro.rawValue && $0.isActive }) {            determinedTier = .pro        } else if info.entitlements.active.values.contains(where: { $0.productIdentifier == Tier.premium.rawValue && $0.isActive }) {            determinedTier = .premium        } else if info.entitlements.active.values.contains(where: { $0.productIdentifier == Tier.basic.rawValue && $0.isActive }) {            determinedTier = .basic        }                // Fallback: Check the "image_generation" entitlement if used as a generic entitlement for any tier.        // This part might need adjustment based on your RevenueCat entitlement setup.        // If each tier has its own entitlement, the above is better.        // If "image_generation" is a generic entitlement and productIdentifier on it tells the tier:        if determinedTier == nil, let ent = info.entitlements["image_generation"], ent.isActive {             if let tierFromProduct = Tier(rawValue: ent.productIdentifier) {                 determinedTier = tierFromProduct             }        }        if let newTier = determinedTier {            print("RCManager: Active entitlement found for tier: \(newTier.displayName) with productID: \(newTier.rawValue)")            setActiveTier(newTier)        } else {            print("RCManager: No active tier entitlement found. User is on free plan.")            activeTier = nil            remainingAllowance = 0 // Free users get 0 allowance by default through this system        }    }    private func setActiveTier(_ tier: Tier) {        let oldTier = activeTier        activeTier = tier        let now = Date()        let calendar = Calendar.current        let currentMonth = calendar.component(.month, from: now)        let currentYear = calendar.component(.year, from: now) // Important for year changes!        let resetKey = lastResetPrefix + tier.rawValue                // Store year and month to handle resets correctly across year boundaries        let lastResetYear = UserDefaults.standard.integer(forKey: resetKey + "_year")        let lastResetMonth = UserDefaults.standard.integer(forKey: resetKey + "_month")        let allowanceUDKey = allowanceKeyPrefix + tier.rawValue        if oldTier != tier || lastResetYear != currentYear || lastResetMonth != currentMonth {            // Reset for new month, new year, or tier change            remainingAllowance = tier.allowance            UserDefaults.standard.set(currentYear, forKey: resetKey + "_year")            UserDefaults.standard.set(currentMonth, forKey: resetKey + "_month")            UserDefaults.standard.set(remainingAllowance, forKey: allowanceUDKey)            print("RCManager: Allowance reset for \(tier.displayName). New allowance: \(remainingAllowance)")        } else {            // Load existing for the current month            remainingAllowance = UserDefaults.standard.integer(forKey: allowanceUDKey)            // If key not found, integer returns 0. If tier was active, it should have an allowance.            // This could happen if app was deleted and reinstalled mid-month without a refresh yet.            // A failsafe: if remainingAllowance is 0 but tier is active and it's not a reset, re-set to full.            // However, this might give freebies if they truly used it up.            // For now, we trust the stored value or the reset logic.            print("RCManager: Loaded existing allowance for \(tier.displayName): \(remainingAllowance)")        }    }    func purchase(package: Package) async throws {        let result = try await Purchases.shared.purchase(package: package)        if result.userCancelled {            print("RCManager: Purchase cancelled by user.")            return        }        print("RCManager: Purchase successful. Refreshing customer info.")        // The delegate method will also call refreshCustomerInfo, but calling it here ensures immediate update.        evaluateEntitlements(from: result.customerInfo)    }    /// Consume a specific number of page credits    func consume(pages: Int) {        guard let tier = activeTier else {            print("RCManager: Cannot consume pages. No active tier.")            return        }        guard remainingAllowance > 0 else {            print("RCManager: Cannot consume pages. No remaining allowance for \(tier.displayName).")            return        }        let newAllowance = remainingAllowance - pages        remainingAllowance = max(0, newAllowance) // Ensure it doesn't go below zero        UserDefaults.standard.set(remainingAllowance,                                  forKey: allowanceKeyPrefix + tier.rawValue)        print("RCManager: Consumed \(pages) pages. Remaining for \(tier.displayName): \(remainingAllowance)")    }    /// Check if the user can generate a certain number of pages.    func canGenerate(pages pagesToGenerate: Int) -> Bool {        guard pagesToGenerate > 0 else { return true } // Generating 0 pages is always allowed (or should be handled before calling this)        guard let currentTier = activeTier else {            // No active plan. User needs a plan to generate any pages.            print("RCManager: Usage check: Cannot generate. No active plan. Pages requested: \(pagesToGenerate).")            return false // Free users cannot generate if pagesToGenerate > 0        }        // For existing subscribers, check if they have enough allowance        if remainingAllowance >= pagesToGenerate {            print("RCManager: Usage check: Can generate. Tier: \(currentTier.displayName), Remaining: \(remainingAllowance), Requested: \(pagesToGenerate)")            return true        } else {            print("RCManager: Usage check: Cannot generate. Insufficient allowance. Tier: \(currentTier.displayName), Remaining: \(remainingAllowance), Requested: \(pagesToGenerate)")            return false        }    }}extension RCSubscriptionManager: PurchasesDelegate {    nonisolated func purchases(_ purchases: Purchases,                               receivedUpdated customerInfo: CustomerInfo) {        Task { @MainActor in // Ensure updates happen on the main actor            print("RCManager (Delegate): Received updated customer info. Refreshing...")            await RCSubscriptionManager.shared.refreshCustomerInfo()        }    }}