import Foundationimport SwiftUIimport CoreDataimport CoreImage.CIFilterBuiltins@MainActorclass StoryPageViewModel: ObservableObject {    enum PageItem {        case illustration(image: UIImage, caption: String)        case textPage(index: Int, total: Int, body: String)        case qrCode(id: UUID, url: URL)    }    @Published var isLoading      : Bool = false    @Published var errorMessage   : String?    @Published var images         : [UIImage] = []    @Published var progress       : Double    = 0    @Published var pageItems      : [PageItem] = []    @Published var subjectPhoto   : UIImage?    @Published var subjectPhotoID : String?    @Published var styleTile      : UIImage?    @Published var styleTileID    : String?    private  var subjectPhotoJPEG : Data?    @AppStorage("memoirPageCount")          private var pageCountSetting      = 2    @AppStorage("memoirArtStyle")           private var artStyleRaw           = ArtStyle.realistic.rawValue    @AppStorage("memoirCustomArtStyleText") private var customArtStyleText    = ""    @AppStorage("memoirEthnicity")          private var ethnicity             = ""    @AppStorage("memoirGender")             private var gender                = ""    @AppStorage("memoirOtherPersonalDetails") private var otherDetails        = ""    private var currentArtStyle : ArtStyle { ArtStyle(rawValue: artStyleRaw) ?? .realistic }    private var faceDescription : String?    private let promptGen : PromptGenerator    private let imageCtx  : ImageContext    private let imageSvc  : OpenAIImageService    private let openAIKey : String    init() {        guard let key = Bundle.main.object(forInfoDictionaryKey: "OPENAI_API_KEY") as? String,              !key.isEmpty, !key.contains("YOUR_API") else {            fatalError("OPENAI_API_KEY missing or invalid")        }        openAIKey = key        promptGen = PromptGenerator(apiKey: key)        imageCtx  = ImageContext(apiKey: key)        imageSvc  = OpenAIImageService(apiKey: key)    }    func expectedPageCount() -> Int { pageCountSetting }    var  styleTilePublic: UIImage? { styleTile }        private func ensureSubjectPhotoIsRegistered() async {        guard subjectPhotoID == nil, let shot = subjectPhoto else { return }        do {            let (fid, jpeg) = try await imageCtx.createReference(from: shot)            subjectPhotoID   = fid            subjectPhotoJPEG = jpeg            print("✅ head-shot uploaded →", fid)        } catch {            print("🚫 head-shot upload failed:", error.localizedDescription)        }    }    private func ensureFaceDescription() async {        guard faceDescription == nil,              let fid = subjectPhotoID else { return }        do {            faceDescription = try await imageCtx.faceDescriptor(                fileID: fid,                jpegData: subjectPhotoJPEG,                race: self.ethnicity,                gender: self.gender            )                        if let desc = faceDescription {                print("✅ face descriptor →", desc)            } else {                print("⚠️ Face descriptor was nil after successful API call.")            }        } catch {            print("🚫 face descriptor failed:", error.localizedDescription)            faceDescription = nil        }    }    private let traitOpposites: [String : [String]] = [        "light skin": ["dark brown skin", "very dark skin"], "pale skin": ["medium-brown skin", "dark skin"],        "fair skin": ["brown skin", "dark skin"], "dark skin": ["pale caucasian skin", "light skin"],        "brown skin": ["very light skin", "pale skin"], "blond hair": ["jet-black hair", "dark-brown hair"],        "light-blond hair": ["black hair", "dark-brown hair"], "brown hair": ["blond hair", "jet-black hair"],        "black hair": ["light-blond hair", "gray hair"], "gray hair": ["blond hair", "black hair", "vibrant red hair"],        "straight texture": ["tight coils", "kinky curly texture"], "wavy texture": ["pin-straight hair"],        "curly texture": ["pin-straight hair"], "tight coils": ["straight texture"], "male": ["female presentation"],        "female": ["male presentation"]    ]    private func negativesOpposite(to identity: [String]) -> String {        let idLower = identity.joined(separator: ", ").lowercased()        var bans: Set<String> = []        for (trait, oppo) in traitOpposites where idLower.contains(trait) { bans.formUnion(oppo) }        bans.formUnion(["incorrect gender presentation", "mismatched race or ethnicity", "incorrect skin tone", "interracial family (unless specified)"])        if bans.isEmpty { bans.insert("mismatched facial features") }        return "NEGATIVE: " + bans.joined(separator: ", ") + "."    }    private func buildIdentityPrompt() -> String {        var identityBits: [String] = []        if let vision = faceDescription, !vision.isEmpty { identityBits.append(vision) }        if !otherDetails.isEmpty { identityBits.append(otherDetails) }        guard !identityBits.isEmpty else { return "" }        let positive = "CHARACTERS: \(identityBits.joined(separator: ", ")). Faces must keep *all* those traits. Family and close friends default to the same race and similar skin-tone unless the script explicitly says otherwise."        let negative = negativesOpposite(to: identityBits)        return positive + " " + negative + " "    }        private func enrich(memory rawText: String) async throws -> String {        let identity = self.faceDescription ?? "the narrator"                let systemPrompt = """        You are a scene-enriching assistant. Your job is to rewrite a user's memory into a rich, detailed paragraph suitable for generating a detailed image prompt.        RULES:        1.  The main character of the story is: "\(identity)". Refer to them using this description.        2.  From the context of the memory, infer a plausible age for every character and add it to their description.        3.  For **any other characters**, handle their description as follows:            a. First, you **must** use any specific descriptions from the text (e.g., "Brandon was black", "a girl with blonde hair").            b. If the text does **not** specify a race or ethnicity for a character, you **must** assume they share the same race and a similar skin tone as the main character.            c. After establishing their appearance, invent other plausible details like clothing and expression if they are not mentioned.        4.  Describe the **setting and the specific actions** in clear, unambiguous detail.        5.  Do not change the core events of the memory. Your goal is to make the description more vivid and explicit, **honoring and preserving all details from the original text.**        6.  Your entire response must be ONLY the rewritten paragraph. No extra text or explanation.        """                let body: [String: Any] = [            "model": "gpt-4o-mini",            "messages": [                ["role": "system", "content": systemPrompt],                ["role": "user", "content": rawText]            ],            "temperature": 0.4        ]                var req = URLRequest(url: URL(string: "https://api.openai.com/v1/chat/completions")!)        req.httpMethod = "POST"        req.addValue("Bearer \(openAIKey)", forHTTPHeaderField: "Authorization")        req.addValue("application/json", forHTTPHeaderField: "Content-Type")        req.httpBody = try JSONSerialization.data(withJSONObject: body)                print("✍️ Enriching memory text...")        let (data, _) = try await URLSession.shared.data(for: req)                struct Choice: Decodable { struct Msg: Decodable { let content: String? }; let message: Msg }        struct Root: Decodable { let choices: [Choice] }                let enrichedText = try JSONDecoder().decode(Root.self, from: data).choices.first?.message.content ?? rawText        print(" enriched text → \(enrichedText)")        return enrichedText    }        /// A temporary struct to hold a memory and its inferred chronological age.    private struct ChronologicalMemory {        let entry: MemoryEntry        let age: Int    }    /// Uses an LLM to extract the user's age from the memory text.    private func extractAge(from memoryText: String) async -> Int? {        let systemPrompt = """        You are a data extraction expert. Your task is to read a user's memory and determine the user's age at the time of the event.        - Look for explicit mentions of age like "I was 13", "when I turned ten", "at age seven".        - If no age is explicitly mentioned, infer a plausible age based on the context (e.g., "my first day of high school" -> 14, "learning to drive" -> 16, "graduating college" -> 22, "my first grandchild was born" -> 55).        - You MUST respond with ONLY a single integer number and nothing else. For example: 13.        - If you cannot determine an age with reasonable confidence, respond with 999.        """                let body: [String: Any] = [            // ✅ UPDATED to the cheaper, faster model for this simple task.            "model": "gpt-3.5-turbo",            "messages": [                ["role": "system", "content": systemPrompt],                ["role": "user", "content": memoryText]            ],            "temperature": 0.0,            "max_tokens": 5        ]                do {            var req = URLRequest(url: URL(string: "https://api.openai.com/v1/chat/completions")!)            req.httpMethod = "POST"            req.addValue("Bearer \(openAIKey)", forHTTPHeaderField: "Authorization")            req.addValue("application/json", forHTTPHeaderField: "Content-Type")            req.httpBody = try JSONSerialization.data(withJSONObject: body)                        let (data, _) = try await URLSession.shared.data(for: req)                        struct Choice: Decodable { struct Msg: Decodable { let content: String? }; let message: Msg }            struct Root: Decodable { let choices: [Choice] }                        if let responseText = try JSONDecoder().decode(Root.self, from: data).choices.first?.message.content,               let age = Int(responseText.trimmingCharacters(in: .whitespacesAndNewlines)) {                return age            }        } catch {            print("🚫 Age extraction failed:", error.localizedDescription)        }                return nil // Return nil on failure    }    func generateStorybook(forProfileID id: UUID) async {        isLoading = true        errorMessage = nil        progress = 0        images.removeAll()        pageItems.removeAll()        await ensureSubjectPhotoIsRegistered()        await ensureFaceDescription()        do {            let entries = try await fetchMemoryEntries(for: id)            let chosen  = await rankMemoriesWithLLM(entries, top: pageCountSetting)                        guard !chosen.isEmpty else {                throw NSError(domain: "MemoirAI", code: 1, userInfo: [NSLocalizedDescriptionKey: "No memories were selected to generate the story."])            }            // --- SORT THE CHOSEN MEMORIES CHRONOLOGICALLY ---            print("🕥 Starting chronological sorting of \(chosen.count) memories...")            var chronologicalMemories: [ChronologicalMemory] = []                        // Use a TaskGroup to run age extraction in parallel for efficiency            await withTaskGroup(of: ChronologicalMemory?.self) { group in                for entry in chosen {                    group.addTask {                        guard let text = entry.text, !text.isEmpty else { return nil }                        // Default to a high age (999) if extraction fails, to sort them last.                        let age = await self.extractAge(from: text) ?? 999                        print(" -> Memory inferred age: \(age) for entry: \(entry.id?.uuidString ?? "N/A")")                        return ChronologicalMemory(entry: entry, age: age)                    }                }                                for await chronoMemory in group {                    if let memory = chronoMemory {                        chronologicalMemories.append(memory)                    }                }            }                        // Sort the temporary array by the extracted age            chronologicalMemories.sort { $0.age < $1.age }                        // Create the final, sorted list of entries to be generated            let sortedEntries = chronologicalMemories.map { $0.entry }            print("✅ Chronological sorting complete.")                        // --- USE THE NEWLY SORTED ARRAY FOR GENERATION ---            let identityPrefix = buildIdentityPrompt()            var generated: [UIImage] = []            for (idx, entry) in sortedEntries.enumerated() { // <-- Use sortedEntries here                guard let entryID = entry.id else { continue }                let raw = entry.text?.trimmingCharacters(in: .whitespacesAndNewlines) ?? ""                guard !raw.isEmpty else { continue }                let enrichedTranscript = try await enrich(memory: raw)                guard let content = try await promptGen.generatePrompts(                    from: enrichedTranscript,                    pageCount: 1,                    chosenArtStyle: currentArtStyle,                    customArtStyleDetails: customArtStyleText                ).first else {                    print("⚠️ Could not generate content for memory entry. Skipping.")                    continue                }                var promptToSend = identityPrefix + content.imagePromptText                if currentArtStyle == .realistic {                    promptToSend += " Camera pulled back, face partly turned away or softly out of focus so exact features are not discernible. Or another method where the face isn’t perfectly clear."                }                print("🖼️ FINAL PROMPT ►", promptToSend)                let img = try await imageSvc.generateImages(                    prompt: promptToSend, n: 1, size: "1792x1024"                ).first ?? UIImage()                generated.append(img)                pageItems.append(.illustration(image: img, caption: content.pageDisplayText))                let chunks = raw.paginated()                for (i, chunk) in chunks.enumerated() {                    pageItems.append(.textPage(index: i + 1, total: chunks.count, body: chunk))                }                pageItems.append(.qrCode(id: entryID, url: URL(string: "memoirai://memory/\(entryID.uuidString)")!))                progress = Double(idx + 1) / Double(sortedEntries.count)            }            images = generated        } catch {            errorMessage = error.localizedDescription            print("StoryPageViewModel ERROR:", error.localizedDescription)        }        isLoading = false    }    private func fetchMemoryEntries(for profileID: UUID) async throws -> [MemoryEntry] {        let ctx = PersistenceController.shared.container.viewContext        return try await ctx.perform {            let req: NSFetchRequest<MemoryEntry> = MemoryEntry.fetchRequest()            req.predicate = NSPredicate(format: "profileID == %@", profileID as CVarArg)            // No longer need to sort by createdAt here, as we'll do a chronological sort later.            return try ctx.fetch(req)        }    }    private struct MemoryStub: Codable { let id: UUID; let summary: String }    private struct ChatMessage: Encodable { let role: String; let content: String }    private struct ChatCompletionRequest: Encodable {        let model: String; let messages: [ChatMessage]        let max_tokens: Int; let temperature: Double    }    private func rankMemoriesWithLLM(_ all: [MemoryEntry], top n: Int) async -> [MemoryEntry] {        guard n < all.count else { return all }        let stubs = all.compactMap { mem -> MemoryStub? in            guard let id = mem.id, let txt = mem.text?.trimmingCharacters(in: .whitespacesAndNewlines), !txt.isEmpty else { return nil }            return MemoryStub(id: id, summary: txt.split(separator: " ").prefix(25).joined(separator: " "))        }        guard let stubJSON = try? JSONEncoder().encode(stubs), let stubStr = String(data: stubJSON, encoding: .utf8) else {            return Array(all.prefix(n))        }        let system = ChatMessage(role: "system", content: "You are a memoir editor. Pick the \(n) most emotionally significant memories.")        let user = ChatMessage(role: "user", content: "Return ONLY JSON { \"top\": [\"uuid1\",\"uuid2\"] }. \nMemories: \(stubStr)")        let req = ChatCompletionRequest(model: "gpt-4o-mini", messages: [system, user], max_tokens: 256, temperature: 0)        var urlReq = URLRequest(url: URL(string: "https://api.openai.com/v1/chat/completions")!)        urlReq.httpMethod = "POST"        urlReq.httpBody   = try? JSONEncoder().encode(req)        urlReq.addValue("Bearer \(openAIKey)", forHTTPHeaderField: "Authorization")        urlReq.addValue("application/json", forHTTPHeaderField: "Content-Type")        do {            let (data, _) = try await URLSession.shared.data(for: urlReq)                        guard let content = extractContent(from: data) else {                print("⚠️ LLM ranking failed to extract content.")                return Array(all.prefix(n))            }                        guard let idsDict = try? JSONDecoder().decode([String:[UUID]].self, from: Data(content.utf8)),                  let ids = idsDict["top"] else {                print("⚠️ LLM ranking failed to decode UUIDs from content: \(content)")                return Array(all.prefix(n))            }            let idOrder = ids.enumerated().reduce(into: [UUID: Int]()) { $0[$1.element] = $1.offset }            return all.filter { $0.id.map(ids.contains) ?? false }                      .sorted {                          guard let id1 = $0.id, let id2 = $1.id,                                let order1 = idOrder[id1], let order2 = idOrder[id2] else { return false }                          return order1 < order2                      }        } catch {            print("LLM ranking failed:", error.localizedDescription)            return Array(all.prefix(n))        }    }        private func extractContent(from data: Data) -> String? {        guard let root = try? JSONSerialization.jsonObject(with: data) as? [String: Any],              let choices = root["choices"] as? [[String: Any]],              let msgDict = choices.first?["message"] as? [String: Any],              let content = msgDict["content"] as? String else {            return nil        }                if let startRange = content.range(of: "{"), let endRange = content.range(of: "}", options: .backwards) {            return String(content[startRange.lowerBound...endRange.upperBound])        }                return content    }}extension UIImage {    func resized(maxSide: CGFloat) -> UIImage {        let longest = max(size.width, size.height)        guard longest > maxSide else { return self }        let scale  = maxSide / longest        let newSz  = CGSize(width: size.width * scale, height: size.height * scale)        UIGraphicsBeginImageContextWithOptions(newSz, false, 0)        draw(in: CGRect(origin: .zero, size: newSz))        let out = UIGraphicsGetImageFromCurrentImageContext() ?? self        UIGraphicsEndImageContext()        return out    }    static func qrCode(from text: String, size: CGFloat = 300) -> UIImage {        let ctx = CIContext()        let f   = CIFilter.qrCodeGenerator()        f.message = Data(text.utf8)        guard let ci = f.outputImage else { return UIImage() }        let scaleX = size / ci.extent.size.width        let scaleY = size / ci.extent.size.height        let scaled = ci.transformed(by: .init(scaleX: scaleX, y: scaleY))        if let cg = ctx.createCGImage(scaled, from: scaled.extent) {            return UIImage(cgImage: cg)        }        return UIImage()    }}extension String {    func paginated(wordsPerPage: Int = 130) -> [String] {        let words = split { $0.isWhitespace }        guard words.count > wordsPerPage else { return [self] }        var pages: [String] = []        var i = 0        while i < words.count {            let j = min(i + wordsPerPage, words.count)            pages.append(words[i..<j].joined(separator: " "))            i += wordsPerPage        }        return pages    }}