import Foundationimport SwiftUIimport CoreDataimport CoreImage.CIFilterBuiltins@MainActorclass StoryPageViewModel: ObservableObject {    /// A single “page” in the final storybook, either an image+caption or a chunk of text or a QR code.    enum PageItem {        case illustration(image: UIImage, caption: String)        case textPage(index: Int, total: Int, body: String)        case qrCode(id: UUID, url: URL) // ← QR-code page    }    @Published var isLoading    = false    @Published var errorMessage : String?    @Published var images       : [UIImage] = []    @Published var progress     : Double    = 0   // 0 … 1    @Published var pageItems    : [PageItem] = []    // Personalization & reference IDs    @Published var subjectPhoto   : UIImage?                 // head-shot    @Published var subjectPhotoID : String?                  // head-shot OpenAI ID    @Published var styleTile      : UIImage? = UIImage(named: "kidsref") // style-tile    @Published var styleTileID    : String?                  // style-tile OpenAI ID    @AppStorage("memoirPageCount")          private var pageCountSetting   = 2    @AppStorage("memoirArtStyle")           private var artStyleRaw        = ArtStyle.realistic.rawValue    @AppStorage("memoirCustomArtStyleText") private var customArtStyleText = ""    private var currentArtStyle: ArtStyle {        ArtStyle(rawValue: artStyleRaw) ?? .realistic    }    private let promptGen : PromptGenerator    private let imageCtx  : ImageContext    private let imageSvc  : OpenAIImageService    init() {        guard let key = Bundle.main.object(forInfoDictionaryKey: "OPENAI_API_KEY") as? String,              !key.isEmpty,              !key.contains("YOUR_API") else {            fatalError("🔑 OPENAI_API_KEY missing or invalid in Info.plist")        }        promptGen = PromptGenerator(apiKey: key)        imageCtx  = ImageContext(apiKey: key)        imageSvc  = OpenAIImageService(apiKey: key)    }    /// How many AI illustrations to generate (N from user settings).    func expectedPageCount() -> Int {        pageCountSetting    }    /// Main entry: for each saved memory (up to N), generate one illustration + its paginated text pages + a QR-code page.    func generateStorybook(forProfileID id: UUID) async {        isLoading    = true        errorMessage = nil        progress     = 0        images       = []        pageItems    = []        defer { isLoading = false }        do {            // 1) Load all MemoryEntry objects for this profile.            let allEntries = try await fetchMemoryEntries(for: id)            // 2) Only keep up to N entries for illustration.            let entries = Array(allEntries.prefix(pageCountSetting))            guard !entries.isEmpty else {                throw NSError(domain: "MemoirAI",                              code: 1,                              userInfo: [NSLocalizedDescriptionKey:                                         "No memories recorded for this profile."])            }            // 3) For each entry, produce illustration + text pages + QR code.            var generatedImages: [UIImage] = []            let totalImages = entries.count            for (idx, entry) in entries.enumerated() {                guard let entryID = entry.id else {                // ← NEW                    continue                                       // skip if id == nil                }                // Trim and skip empty text                                let text = entry.text?.trimmingCharacters(in: .whitespacesAndNewlines) ?? ""                guard !text.isEmpty else { continue }                // a) Ask LLM for a single illustration prompt (pageCount: 1).                let content = try await promptGen.generatePrompts(                    from: text,                    pageCount: 1,                    chosenArtStyle: currentArtStyle,                    customArtStyleDetails: customArtStyleText                ).first!                // b) Enrich prompt using styleTile & headshot if kidsBook style.                var refs: [String] = []                if currentArtStyle == .kidsBook, let tileID = styleTileID {                    refs.append(tileID)                }                if let headID = subjectPhotoID {                    refs.append(headID)                }                let enriched = try await imageCtx.enrichPrompts(                    prompts: [ImagePrompt(text: content.imagePromptText,                                          referenceImageIDs: refs)],                    withPhotos: [styleTile, subjectPhoto].compactMap { $0 }                ).first!                // c) Generate the image via DALL·E (or OpenAI).                let imgs = try await imageSvc.generateImages(                    prompt: enriched.text,                    referencedImageIDs: enriched.referenceImageIDs,                    n: 1,                    size: "1792x1024"                )                let img = imgs.first ?? UIImage()                generatedImages.append(img)                // d) Append the illustration page for this memory.                pageItems.append(.illustration(image: img,                                               caption: content.pageDisplayText))                // e) Paginate the memory text into chunks of ~130 words each, then append text pages.                let textPages = text.paginated()                for (i, chunk) in textPages.enumerated() {                    pageItems.append(.textPage(index: i + 1,                                               total: textPages.count,                                               body: chunk))                }                // f) Append a QR-code page with a deep‐link to this memory’s detail in the app.                // f) Append a QR-code page with a deep-link to this memory’s detail in the app.                let deepLink = URL(string: "memoirai://memory/\(entryID.uuidString)")!   // ← use entryID                pageItems.append(.qrCode(id: entryID, url: deepLink))                    // ← use entryID                // g) Update progress (by illustration count, not pages).                progress = Double(idx + 1) / Double(totalImages)            }            // 4) Commit the list of generated images so the view can consume them for paywall logic.            images = generatedImages        } catch {            errorMessage = error.localizedDescription            print("[StoryPageViewModel ERROR] \(error.localizedDescription)")        }    }    /// Fetch all MemoryEntry objects for the given profile, sorted by creation date.    private func fetchMemoryEntries(for profileID: UUID) async throws -> [MemoryEntry] {        let ctx = PersistenceController.shared.container.viewContext        return try await ctx.perform {            let req: NSFetchRequest<MemoryEntry> = MemoryEntry.fetchRequest()            req.predicate = NSPredicate(format: "profileID == %@", profileID as CVarArg)            req.sortDescriptors = [                NSSortDescriptor(keyPath: \MemoryEntry.createdAt, ascending: true)            ]            return try ctx.fetch(req)        }    }}extension UIImage {    /// Generates a QR code UIImage from the given string.    /// - Parameter text: The data (URL string) to encode in the QR code.    /// - Parameter size: The side length (in points) of the final square image.    /// - Returns: A square UIImage of the specified size (or an empty UIImage on failure).    static func qrCode(from text: String, size: CGFloat = 300) -> UIImage {        let context = CIContext()        let filter  = CIFilter.qrCodeGenerator()        filter.message = Data(text.utf8)        guard let ciImage = filter.outputImage else {            return UIImage()        }        // Scale up the small CIImage to the desired size:        let scaleX = size / ciImage.extent.size.width        let scaleY = size / ciImage.extent.size.height        let scaledCI = ciImage.transformed(by: CGAffineTransform(scaleX: scaleX, y: scaleY))        if let cgImage = context.createCGImage(scaledCI, from: scaledCI.extent) {            return UIImage(cgImage: cgImage)        }        return UIImage()    }}extension String {    /// Splits the string into pages of roughly `wordsPerPage` words each.    func paginated(wordsPerPage: Int = 130) -> [String] {        let words = self.split { $0.isWhitespace }        guard words.count > wordsPerPage else {            return [self]        }        var pages: [String] = []        var start = 0        while start < words.count {            let end = min(start + wordsPerPage, words.count)            pages.append(words[start..<end].joined(separator: " "))            start += wordsPerPage        }        return pages    }}