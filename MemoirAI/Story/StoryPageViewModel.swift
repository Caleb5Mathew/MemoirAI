import SwiftUIimport CoreData@MainActorclass StoryPageViewModel: ObservableObject {    @Published var isLoading     = false    @Published var errorMessage  : String?    @Published var images        : [UIImage] = []    @Published var progress      : Double    = 0      // 0 â€¦ 1    @Published var storyContents : [StoryPageContent] = []    // Personalization & reference IDs    @Published var subjectPhoto      : UIImage?                    // head-shot    @Published var subjectPhotoID    : String?                     // head-shot OpenAI ID    @Published var styleTile         : UIImage? = UIImage(named: "kidsref")  // Style-tile image    @Published var styleTileID       : String?                     // style-tile OpenAI ID    @AppStorage("memoirPageCount")          private var pageCountSetting   = 2    @AppStorage("memoirArtStyle")           private var artStyleRaw        = ArtStyle.realistic.rawValue    @AppStorage("memoirCustomArtStyleText") private var customArtStyleText = ""    private var currentArtStyle: ArtStyle {        ArtStyle(rawValue: artStyleRaw) ?? .realistic    }    private let promptGen : PromptGenerator    private let imageCtx  : ImageContext    private let imageSvc  : OpenAIImageService    init() {        guard let key = Bundle.main                .object(forInfoDictionaryKey: "OPENAI_API_KEY") as? String,              !key.isEmpty,              !key.contains("YOUR_API") else {            fatalError("ðŸ”‘ OPENAI_API_KEY missing or invalid in Info.plist")        }        promptGen = PromptGenerator(apiKey: key)        imageCtx  = ImageContext(apiKey: key)        imageSvc  = OpenAIImageService(apiKey: key)    }    func expectedPageCount() -> Int { pageCountSetting }    /// Main entry: fetch transcript, craft prompts, enrich style, draw with DALLÂ·E    func generateStorybook(forProfileID id: UUID) async {        isLoading     = true        errorMessage  = nil        progress      = 0        images        = []        storyContents = []        defer { isLoading = false }        do {            // 1) fetch transcript            let transcript = try await fetchTranscript(for: id)            guard !transcript.isEmpty else {                throw NSError(domain: "MemoirAI",                              code: 1,                              userInfo: [NSLocalizedDescriptionKey:                                         "No memories recorded for this profile."])            }            // 2) generate raw StoryPageContent            let baseContent = try await promptGen.generatePrompts(                from: transcript,                pageCount: pageCountSetting,                chosenArtStyle: currentArtStyle,                customArtStyleDetails: customArtStyleText            )            storyContents = baseContent            // 3) prepare reference image IDs for enrichment and generation            var referenceImageIDs: [String] = []            // 3a) style tile first so ImageContext.enrich uses it as style exemplar            if currentArtStyle == .kidsBook,               let tileID = styleTileID {                referenceImageIDs.append(tileID)            }            // 3b) then the userâ€™s head-shot as subject exemplar            if let headID = subjectPhotoID {                referenceImageIDs.append(headID)            }            // 4) enrich all image prompts _once_ via ImageContext            let rawPrompts: [ImagePrompt] = storyContents.map { content in                ImagePrompt(                    text: content.imagePromptText,                    referenceImageIDs: referenceImageIDs                )            }            let referencePhotos = [styleTile, subjectPhoto].compactMap { $0 }            let enriched = try await imageCtx.enrichPrompts(                prompts: rawPrompts,                withPhotos: referencePhotos            )            guard enriched.count == baseContent.count else {                throw NSError(domain: "MemoirAI",                              code: 2,                              userInfo: [NSLocalizedDescriptionKey:                                         "Prompt/text count mismatch"])            }            // 5) render each page            var rendered: [UIImage] = []            for (idx, promptObj) in enriched.enumerated() {                // build the verse with double-space line breaks                let verse = baseContent[idx]                    .pageDisplayText                    .split(separator: "\n")                    .map(String.init)                    .joined(separator: "  \n")                // final prompt text is just the enriched text for kidsBook                let finalPrompt = promptObj.text                print("[StoryPageViewModel] ðŸš€ Final DALLÂ·E prompt for page \(idx+1):\n\(finalPrompt)\n---")                // generate the image with references                let imgs = try await imageSvc.generateImages(                    prompt: finalPrompt,                    referencedImageIDs: promptObj.referenceImageIDs,                    n: 1,                    size: "1792x1024"                )                rendered.append(imgs.first ?? UIImage())                progress = Double(idx + 1) / Double(enriched.count)            }            images = rendered        } catch {            errorMessage = error.localizedDescription            print("[StoryPageViewModel ERROR] \(error.localizedDescription)")        }    }    private func fetchTranscript(for profileID: UUID) async throws -> String {        let ctx = PersistenceController.shared.container.viewContext        return try await ctx.perform {            let req: NSFetchRequest<MemoryEntry> = MemoryEntry.fetchRequest()            req.predicate       = NSPredicate(format: "profileID == %@", profileID as CVarArg)            req.sortDescriptors = [NSSortDescriptor(keyPath: \MemoryEntry.createdAt,                                                    ascending: true)]            return try ctx.fetch(req)                .compactMap { $0.text?.trimmingCharacters(in: .whitespacesAndNewlines) }                .joined(separator: "\n\n")        }    }}