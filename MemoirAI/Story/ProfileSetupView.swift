//////  ProfileSetupView.swift//  MemoirAI////  Now supports in-place cropping of the selected head-shot, optional race/ethnicity, and gender.//import SwiftUIimport UIKitfileprivate struct LocalColors {    static let softCream   = Color(red: 0.98, green: 0.96, blue: 0.89)    static let terracotta  = Color(red: 0.82, green: 0.45, blue: 0.32)    static let defaultGray = Color.gray    static let subtleBG    = Color.black.opacity(0.05)}fileprivate extension Font {    static func appSerif(_ size: CGFloat) -> Font {        .system(size: size, design: .serif)    }}// Custom Gender Picker options (Decline option removed)fileprivate enum GenderOption: String, CaseIterable, Identifiable {    case male = "Male"    case female = "Female"    case other = "Other"        var id: Self { self }}// Custom TextField Style for the formstruct AppTextFieldStyle: TextFieldStyle {    func _body(configuration: TextField<Self._Label>) -> some View {        configuration            .font(.appSerif(18))            .padding(12)            .background(LocalColors.subtleBG)            .clipShape(RoundedRectangle(cornerRadius: 10))            .overlay(                RoundedRectangle(cornerRadius: 10)                    .stroke(Color.gray.opacity(0.3), lineWidth: 1)            )    }}struct ProfileSetupView: View {        // External bindings    @Binding var headshotImage: UIImage?    @Binding var name: String    @Binding var race: String    @Binding var gender: String    let onGenerate: () -> Void        // NEW: Auto-save using AppStorage    @AppStorage("memoirEthnicity") private var savedEthnicity: String = ""    @AppStorage("memoirGender") private var savedGender: String = ""        // Dismiss    @Environment(\.dismiss) private var dismiss        // Pick / crop state    @State private var showSourceChooser = false    @State private var showImagePicker   = false    @State private var showCropper       = false    @State private var pickerSource: UIImagePickerController.SourceType = .photoLibrary        // Internal state for the gender picker, defaulting to .male    @State private var selectedGender: GenderOption = .male    @State private var customGender: String = ""        // Computed property to check if the button should be enabled    var isGenerateButtonDisabled: Bool {        headshotImage == nil    }        var body: some View {        ZStack {            LocalColors.softCream.ignoresSafeArea()                        ScrollView { // Use a ScrollView to prevent overflow on smaller screens                VStack {                    // ── Header (dismiss) ──────────────────────────                    HStack {                        Button {                            dismiss()                        } label: {                            Image(systemName: "xmark")                                .font(.title2)                                .foregroundColor(.black)                                .padding(8)                                .background(LocalColors.subtleBG)                                .clipShape(Circle())                        }                        Spacer()                    }                    .padding()                                        Spacer(minLength: 12)                                        // ── Photo / picker ───────────────────────────                    Group {                        if let shot = headshotImage {                            Image(uiImage: shot)                                .resizable()                                .scaledToFit()                                .frame(maxWidth: 200, maxHeight: 200)                                .clipShape(RoundedRectangle(cornerRadius: 20))                                .shadow(radius: 4)                                .padding(.bottom, 8)                                                        Menu {                                Button("Crop Photo")    { showCropper       = true }                                Button("Replace Photo") { showSourceChooser = true }                            } label: {                                Text("Edit Photo")                                    .font(.callout.weight(.semibold))                            }                                                    } else {                            Button { showSourceChooser = true } label: {                                VStack(spacing: 12) {                                    Image(systemName: "person.crop.square")                                        .font(.system(size: 80))                                        .foregroundColor(LocalColors.defaultGray.opacity(0.6))                                    Text("Add Head-shot")                                        .font(.headline.weight(.semibold))                                        .foregroundColor(.black)                                }                                .frame(maxWidth: .infinity, minHeight: 200)                                .background(LocalColors.subtleBG)                                .clipShape(RoundedRectangle(cornerRadius: 20))                            }                        }                    }                    .padding(.horizontal, 60)                    // --- USER INPUT FIELDS ---                    VStack(spacing: 16) {                        // Labeled input so the purpose is clear even after the user starts typing                        VStack(alignment: .leading, spacing: 4) {                            Text("Ethnicity / Race")                                .font(.headline)                                .foregroundColor(.black)                            TextField("e.g., Hispanic, Asian, Black", text: $race)                                .textFieldStyle(AppTextFieldStyle())                        }                        .onChange(of: race) { newValue in                            // Auto-save when user types                            savedEthnicity = newValue                        }                                                // --- Gender Picker ---                        Picker("Gender", selection: $selectedGender) {                            ForEach(GenderOption.allCases) { option in                                Text(option.rawValue).tag(option)                            }                        }                        .pickerStyle(SegmentedPickerStyle())                        .onChange(of: selectedGender) { _ in                            updateGenderBinding()                            // Auto-save when user changes selection                            savedGender = gender                        }                                                // --- Custom Gender Text Field ---                        if selectedGender == .other {                            TextField("Please specify gender", text: $customGender)                                .textFieldStyle(AppTextFieldStyle())                                .transition(.opacity.animation(.easeIn))                                .onChange(of: customGender) { _ in                                    updateGenderBinding()                                    // Auto-save custom gender                                    savedGender = gender                                }                        }                    }                    .padding(.horizontal, 40)                    .padding(.top, 24)                                        // ── Explanation text ────────────────────────                    Text("""                        A head-shot helps lock the appearance.                        Providing race/ethnicity and gender helps the AI create a more faithful and respectful portrait.                        """)                        .font(.caption)                        .multilineTextAlignment(.center)                        .foregroundColor(.gray)                        .padding(.horizontal, 40)                        .padding(.top, 12)                                        Spacer()                                        // ── Generate CTA ────────────────────────────                    Button {                        onGenerate(); dismiss()                    } label: {                        Text("Save & Generate")                            .font(.headline.weight(.semibold))                            .foregroundColor(.white)                            .frame(maxWidth: .infinity)                            .padding(.vertical, 16)                            .background(LocalColors.terracotta)                            .clipShape(RoundedRectangle(cornerRadius: 16))                    }                    .disabled(isGenerateButtonDisabled)                    .opacity(isGenerateButtonDisabled ? 0.6 : 1.0)                    .padding(.horizontal, 40)                    .padding(.vertical, 30)                }            }        }        // ── Pick / crop modals ─────────────────────────────        .confirmationDialog("Add Photo", isPresented: $showSourceChooser) {            if UIImagePickerController.isSourceTypeAvailable(.camera) {                Button("Take Photo") {                    pickerSource = .camera                    showImagePicker = true                }            }            Button("Choose from Library") {                pickerSource = .photoLibrary                showImagePicker = true            }            Button("Cancel", role: .cancel) { }        }        .sheet(isPresented: $showImagePicker) {            ImagePicker(source: pickerSource, allowsCropping: true) { img in                headshotImage = img            }        }        .sheet(isPresented: $showCropper) {            if let current = headshotImage {                ImageCropperView(image: current) { cropped in                    headshotImage = cropped                }            }        }        .onAppear {            // Auto-populate from saved values            if race.isEmpty && !savedEthnicity.isEmpty {                race = savedEthnicity            }            if gender.isEmpty && !savedGender.isEmpty {                gender = savedGender                setInitialGenderState()            } else {                setInitialGenderState()            }        }    }        // Populates the internal state from the external binding when the view appears    private func setInitialGenderState() {        if let standardOption = GenderOption(rawValue: gender) {            // Handles "Male" or "Female" if they are already in the binding            selectedGender = standardOption        } else if !gender.isEmpty {            // Handles a pre-existing custom gender from the binding            selectedGender = .other            customGender = gender        } else {            // The binding is empty, so set our default and update the binding            selectedGender = .male            updateGenderBinding() // Syncs the binding with the new default state        }    }        // Updates the external binding based on the user's selection    private func updateGenderBinding() {        switch selectedGender {        case .male, .female:            gender = selectedGender.rawValue        case .other:            gender = customGender        }    }}////private struct ImagePicker: UIViewControllerRepresentable {    var source: UIImagePickerController.SourceType    var allowsCropping: Bool    var onPicked: (UIImage) -> Void        func makeCoordinator() -> Coordinator { Coordinator(onPicked: onPicked) }        func makeUIViewController(context: Context) -> UIImagePickerController {        let picker = UIImagePickerController()        picker.sourceType   = source        picker.allowsEditing = allowsCropping        picker.delegate     = context.coordinator        return picker    }    func updateUIViewController(_ uiViewController: UIImagePickerController, context: Context) {}        final class Coordinator: NSObject, UINavigationControllerDelegate, UIImagePickerControllerDelegate {        var onPicked: (UIImage) -> Void        init(onPicked: @escaping (UIImage) -> Void) { self.onPicked = onPicked }                func imagePickerController(_ picker: UIImagePickerController,                                     didFinishPickingMediaWithInfo info: [UIImagePickerController.InfoKey : Any]) {            let key: UIImagePickerController.InfoKey = picker.allowsEditing ? .editedImage : .originalImage            if let img = info[key] as? UIImage { onPicked(img) }            picker.dismiss(animated: true)        }        func imagePickerControllerDidCancel(_ picker: UIImagePickerController) {            picker.dismiss(animated: true)        }    }}////struct ImageCropperView: View {    let image: UIImage    var onFinished: (UIImage) -> Void        @Environment(\.dismiss) private var dismiss        // Drag / zoom state    @State private var scale: CGFloat   = 1    @State private var offset: CGSize   = .zero    @State private var lastScale: CGFloat = 1    @State private var lastOffset: CGSize = .zero        var body: some View {        NavigationStack {            GeometryReader { geo in                ZStack {                    Color.black.opacity(0.9).ignoresSafeArea()                                        // Cropping square frame                    Color.clear                        .frame(width: geo.size.width,                               height: geo.size.width)                        .overlay(                            RoundedRectangle(cornerRadius: 2)                                .stroke(Color.white, lineWidth: 2)                        )                        .clipped()                        .overlay(                            // Movable / zoomable image                            Image(uiImage: image)                                .resizable()                                .scaledToFill()                                .offset(offset)                                .scaleEffect(scale)                                .gesture(                                    DragGesture()                                        .onChanged { value in                                            offset = CGSize(width: lastOffset.width + value.translation.width,                                                            height: lastOffset.height + value.translation.height)                                        }                                        .onEnded { _ in lastOffset = offset }                                )                                .gesture(                                    MagnificationGesture()                                        .onChanged { newScale in                                            scale = lastScale * newScale                                        }                                        .onEnded { _ in lastScale = scale }                                )                        )                        .frame(maxHeight: .infinity, alignment: .center)                }                .toolbar {                    ToolbarItem(placement: .navigationBarLeading) {                        Button("Cancel") { dismiss() }                            .foregroundColor(.white)                    }                    ToolbarItem(placement: .navigationBarTrailing) {                        Button("Save") {                            let cropped = renderCropped(in: geo.size)                            onFinished(cropped)                            dismiss()                        }                        .fontWeight(.semibold)                        .foregroundColor(.white)                    }                }            }        }        .statusBarHidden(true)    }        // Render the visible square into a UIImage    private func renderCropped(in geoSize: CGSize) -> UIImage {        let renderer = ImageRenderer(content:            Image(uiImage: image)                .resizable()                .scaledToFill()                .offset(offset)                .scaleEffect(scale)                .frame(width: geoSize.width,                       height: geoSize.width)        )        renderer.scale = 1        return renderer.uiImage ?? image    }}////struct ProfileSetupView_Previews: PreviewProvider {    @State static var img: UIImage? = nil    @State static var name = ""    @State static var race = ""    @State static var gender = "" // Added for preview        static var previews: some View {        ProfileSetupView(headshotImage: $img,                         name: $name,                         race: $race,                         gender: $gender, // Pass binding                         onGenerate: {            print("Generate button tapped with name: \(name), race: \(race), gender: \(gender)")        })    }}